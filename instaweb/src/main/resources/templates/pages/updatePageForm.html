<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">

<head>
  <meta charset="UTF-8" />
  <title>Update Page</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="/css/universal.css" th:href="@{/css/universal.css}" />
  <!-- 수정폼은 글 작성폼이랑 스타일은 같기 때문에 css 파일 글 작성폼꺼 그대로 사용 -->
  <link rel="stylesheet" href="/css/createPageForm.css" th:href="@{/css/createPageForm.css}" />
</head>

<body>
  <!-- side tab fragment -->
  <div th:replace="fragment/side-tab :: side-tab"></div>
  <div id="header">
    <div class="editor-menu">
      <button id="btn-bold" type="button">
        <b>B</b>
      </button>
      <button id="btn-italic" type="button">
        <i>I</i>
      </button>
      <button id="btn-underline" type="button">
        <u>U</u>
      </button>
      <button id="btn-strike" type="button">
        <s>S</s>
      </button>
      <button id="btn-image" type="button" style="width: 45px">IMG</button>
    </div>
  </div>
  <!-- Page 들 ajax 에 의해 로드됨 -->
  <div class="contents">
    <form th:object="${form}" method="post" enctype="multipart/form-data">
      <!-- title -->
      <div class="title">
        <input id="titleInput" type="text" th:field="*{title}" placeholder="제목을 입력하세요"
          oninput="removePlaceholderRed()" />
      </div>
      <!-- 실제 content 저장용 -->
      <textarea id="my-textarea" style="display: none" th:field="*{content}"></textarea>
      <!-- 유저에게 보이는 div -->
      <div id="editor" contenteditable="true" oninput="resizeEditorWhenTyped()"></div>

      <input id="img-selector" type="file" accept="image/*" />

      <!-- type="hidden" 으로 안넘겨주면 null 됨 -->
      <input type="hidden" th:field="*{id}" />
      <input type="hidden" th:field="*{createdTime}" />
      <button id="submitBtn" type="submit">완료</button>
    </form>
  </div>

  <!-- footer -->
  <footer th:replace="fragment/footer :: footer"></footer>

  <!-- 작성된 내용 ajax 로 불러옴  -->
  <script type="text/javascript">

    let xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function () {
      if (xhr.readyState == XMLHttpRequest.DONE) {
        if (xhr.status == 200) {
          let data = JSON.parse(xhr.responseText);

          // key,val = 이미지의 uuid,이미지 File 
          for (let i = 0; i < data.images.length; i++) {
            let file = base64ToFile(data.images[i], data.imgUUIDList[i], 'image/');
            fileMap.set(data.imgUUIDList[i], file);
          }

          //
          const tempDiv = document.createElement("div");
          tempDiv.innerHTML = data.content;
          // Get all <img> elements from the div
          const imgElements = tempDiv.querySelectorAll("img");
          // 이미지 디스플레이
          for (let i = 0; i < imgElements.length; i++) {
            let imgElement = imgElements[i];
            // imgElement.src =
            //   "data:image/jpeg;charset=utf-8;base64," + fileMap.get(data.imgUUIDList[i]);    
            imgElement.src = URL.createObjectURL(fileMap.get(data.imgUUIDList[i]));               
          }


          let editor = document.getElementById("editor");
          editor.innerHTML = tempDiv.innerHTML;
          resizeEditorOnload();
        } else {
          console.error("error");
        }
      }
    };

    window.onload = function () {
      // 페이지 내용 가져옴 
      xhr.open("GET", "/view/ajaxReq?pageId=" + pageId.toString(), true);
      xhr.send();
    };

    function base64ToFile(base64String, fileName, contentType) {
      const byteCharacters = atob(base64String);
      const byteArrays = [];

      for (let offset = 0; offset < byteCharacters.length; offset += 512) {
        const slice = byteCharacters.slice(offset, offset + 512);
        const byteNumbers = new Array(slice.length);

        for (let i = 0; i < slice.length; i++) {
          byteNumbers[i] = slice.charCodeAt(i);
        }

        const byteArray = new Uint8Array(byteNumbers);
        byteArrays.push(byteArray);
      }

      const blob = new Blob(byteArrays, { type: contentType });
      return new File([blob], fileName, { type: contentType });
    }
  </script>


  <!-- createPageForm, updatePageForm 동일하게 사용 -->
  <script>
    let pageId = "[[${form.id}]]";
    // key = Image 의 url, value = Image File
    // let fileList = []; // 유저가 선택한 file 이 담김
    const fileMap = new Map();
    // key,value = UUID,File
    const uploadMap = new Map();

    const form = document.querySelector("form");
    const editor = document.getElementById("editor");
    const btnBold = document.getElementById("btn-bold");
    const btnItalic = document.getElementById("btn-italic");
    const btnUnderline = document.getElementById("btn-underline");
    const btnStrike = document.getElementById("btn-strike");

    const btnImage = document.getElementById("btn-image");
    const imageSelector = document.getElementById("img-selector");

    btnBold.addEventListener("click", function () {
      setStyle("bold");
    });

    btnItalic.addEventListener("click", function () {
      setStyle("italic");
    });

    btnUnderline.addEventListener("click", function () {
      setStyle("underline");
    });

    btnStrike.addEventListener("click", function () {
      setStyle("strikeThrough");
    });

    function setStyle(style) {
      document.execCommand(style);
      focusEditor();
    }

    // 버튼 클릭 시 에디터가 포커스를 잃기 때문에 다시 에디터에 포커스를 해줌
    function focusEditor() {
      editor.focus({ preventScroll: true });
    }

    btnImage.addEventListener("click", function () {
      imageSelector.click();
    });

    imageSelector.addEventListener("change", function (e) {
      const files = e.target.files;
      if (!!files) {
        insertImg(files[0]);
      }
      // 비워주지 않으면 같은 이미지 연속 선택시 imageSelector 'change' triggered 되지 않을 가능성 있음
      this.value = null;
    });

    // 선택한 이미지 editor 에 삽입
    let imgEleCnt = 0;
    function insertImg(file) {
      const reader = new FileReader();
      let url = URL.createObjectURL(file);
      // fileMap.set(url, file);
      // const imgUUID = uuidv4(); // 이미지의 고유 UUID 값 
      const imgUUID = self.crypto.randomUUID();
      fileMap.set(imgUUID, file);

      let imgEle = document.createElement("img");
      imgEle.src = url;
      // imgEle.classList.add(imgEleCnt++);
      imgEle.id = imgUUID;
      let divImgEle = document.createElement("div");
      divImgEle.appendChild(imgEle);

      let selection = window.getSelection();
      // console.log('selection.anchorOffset = ' + selection.anchorOffset);
      // console.log('selection.anchorNode = ' + selection.anchorNode);
      // console.log('selection.anchorNode.parentNode = ' + selection.anchorNode.parentNode);

      // 지정하지 않은 경우 editor 영역에 img 삽입
      if (selection.anchorNode == null) {
        let targetElement = document.getElementById("editor");
        targetElement.appendChild(divImgEle);
      }
      // 글 작성하는 editor 영역에 커서 위치할경우
      else if (selection.anchorNode.parentNode.id === "editor") {
        let range = selection.getRangeAt(0);
        range.insertNode(divImgEle);
      } else {
        // 아닌 경우에는 editor 영역에 img 삽입
        let targetElement = document.getElementById("editor");
        targetElement.appendChild(divImgEle);
      }

      // 이미지 삽입함에 따라 그만큼 editor 의 높이 늘림
      resizeEditorAfterImgInserted(divImgEle, file);
      focusAfterImgInserted();
    }

    function focusAfterImgInserted() {
      let newLineDiv = document.createElement('div');
      // Set the content editable attribute of the new <div> to true
      newLineDiv.setAttribute('contenteditable', 'true');
      let br = document.createElement('br');
      newLineDiv.appendChild(br);
      editor.appendChild(newLineDiv);

      // Set the focus on the inner text of the new <div>
      const range = document.createRange();
      const selection = window.getSelection();
      range.selectNodeContents(br);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    // todo : 컨텐츠, 이미지 모두 ajax 로 전달
    // submit button event listener
    let button = document.getElementById("submitBtn");
    button.addEventListener("click", function (event) {
      // Prevent the default form submission behavior (버튼 클릭시 서버로 폼 전송 방지)
      event.preventDefault();
      // error check, error 없을시 데이터 서버로 전송 시작 
      if (!checkErrors()) {
        // 이미지 정보 먼저 ajax로 보내고 폼 데이터 이후 보냄
        uploadToServer();
      }
    });

    // page 에 error 존재 시 true return 
    function checkErrors() {
      // title 미입력시 에러 
      let title = document.getElementById('titleInput');
      if (title.value.length == 0) {
        title.classList.add('placeholder-red');
        title.focus({ preventScroll: false });
        return true;
      }
      return false;
    }

    function removePlaceholderRed() {
      document.getElementById('titleInput').classList.remove('placeholder-red');
    }

    // files 에 담긴 파일들 formData 에 담아 서버에 ajax request 보냄
    // 페이지 id 도 같이 보냄
    function uploadToServer() {
      // <div contenteditable=true> 에 있는 내용 <textarea> 에 복사
      getContent();

      const form = document.querySelector("form");
      const formData = new FormData();

      // key:pageId, pageId formData 에 추가
      let pageId = "[[${form.id}]]";
      formData.append("pageId", pageId);

      // key:createdTime 
      let createdTime = "[[${form.createdTime}]]"
      // pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS";
      createdTime = createdTime.substring(0, 23);
      formData.append("createdTime", createdTime);

      // key: files
      // key: uuid
      uploadMap.forEach((value, key) => {
        console.log('uuid = ' + key)
        console.log('file = ' + value)
        formData.append("files", value);
        formData.append("uuids", key);
      });

      // key:title
      let title = document.getElementById('titleInput').value;
      formData.append("title", title);

      // key:content
      formData.append("content", document.getElementById("my-textarea").value);

      const xhr = new XMLHttpRequest();
      xhr.open("POST", "/pages/upload", true);
      xhr.onload = function () {
        if (xhr.status === 200) {
          console.log("Files uploaded successfully");
          form.submit();
        } else {
          console.error("Error uploading files");
        }
      };
      xhr.send(formData);
    }

    // <div contenteditable=true> 에 있는 내용 <textarea> 에 복사
    function getContent() {
      insertFisrtLineDiv();
      document.getElementById("my-textarea").value = editor.innerHTML;
      getImgEleFromTextArea();
    }

    // editor 의 첫줄은 <div> 속에 포함안되고 그냥 text object 이 되버림. 
    // 일관성과 폼 입력 후 오류 발생해서 다시 되돌아왔을때 editor 높이 크기 계산 위해 
    function insertFisrtLineDiv() {
      let string = '';
      let i = 0;
      for (; i < editor.innerHTML.length; i++) {
        if (editor.innerHTML[i] == '<') {
          break;
        }
        string += editor.innerHTML[i];
      }

      editor.innerHTML = editor.innerHTML.substring(i);

      let div = document.createElement('div');
      div.innerHTML = string;
      editor.insertBefore(div, editor.firstChild);
    }

    // editor 에 작성된 글에서 <img> 추출
    function getImgEleFromTextArea() {
      const textareaValue = document.getElementById("my-textarea").value;
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = textareaValue;

      // Get all <img> elements from the div
      const imgElements = tempDiv.querySelectorAll("img");

      // uploadMap 에 uuid,file 저장 (서버에 업로드할 파일들)
      for (let i = 0; i < imgElements.length; i++) {
        const imgElement = imgElements[i];
        uploadMap.set(imgElement.id, fileMap.get(imgElement.id));
        imgElement.removeAttribute('src');
      }

      // img src 는 필요없으므로 제거 (서버에 전송 x)
      document.getElementById("my-textarea").value = tempDiv.innerHTML;

    }

    // text editor 에 입력시 editor 크기 조절 
    function resizeEditorWhenTyped() {
      const editor = document.getElementById("editor");
      const minHeight = 500; // Set the desired minimum height
      editor.style.height = "auto"; // Reset the height to auto to recalculate the height based on content
      editor.style.height = Math.max(minHeight, editor.scrollHeight) + "px"; // Set the height to the maximum of minHeight and scroll height
    }

    // 이미지 editor 에 삽입 하고, 그 높이 만큼 editor 의 높이 조절함
    function resizeEditorAfterImgInserted(divImgEle, file) {
      let minHeight = 500;
      const reader = new FileReader();
      const imgEle = document.createElement("img");

      reader.onload = function (event) {
        imgEle.onload = function () {
          // insert 한 img 높이 
          const imageHeight = imgEle.height + 20 + 20; // 위 아래 margin 20
          // wait for scrollHeight reflection 
          setTimeout(function () {
            editor.style.height = "auto";
            editor.style.height = Math.max(minHeight, editor.scrollHeight) + "px";
            // Your code to adjust the editor height here
          }, 100);
        };

        imgEle.src = event.target.result;

      };
      reader.readAsDataURL(file);
    }

    // page onload 시 editor 크기 조절 
    function resizeEditorOnload() {

      // Perform additional actions after the element is displayed
      window.requestAnimationFrame(function () {
        // Your additional actions here
        // This code will run after the element is rendered
        let height = 62; // editor 기본 padding, border 포함
        for (let i = 0; i < editor.childNodes.length; i++) {
          let childNode = editor.childNodes[i];
          height += childNode.offsetHeight;
        }
        editor.style.height = 'auto';
        editor.style.height = Math.max(500, height) + 'px';
      });
    }

  </script>

</body>

</html>